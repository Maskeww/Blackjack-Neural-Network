from memory_profiler import profile
import numpy as np #remove draws from the win-rate metric
import time #Is the feedback to the neural network appropriate?
import itertools
import random
import sys
np.set_printoptions(suppress=True)

from random import shuffle
#gameCount = 0
printMode = False
inverse = False
split = False
double = False
splitTrain = False
doubleTrain = False

overallWin = 0
overallWeights = []

previousWin = 0
previousWeights = []

bestResultsArray = []
bestWeightsArray = []


thorpesSimple = ["H", "H", "D", "D", "H", "S","S","S",
                 "S","S","H", "D","D", "D", "H", "S",
                 "S","S","S","S","H", "D", "D", "D",
                 "S", "S","S","S","S","S","H", "D","D",
                 "D", "S", "S","S","S","S","S","H",
                 "D", "D", "D", "S", "S","S","S","S","S",
                 "H","H", "D", "D", "H", "H","H","H","H",
                 "S","H", "H", "D", "D", "H", "H","H","H",
                 "H","S","H", "H", "D", "D", "H", "H","H",
                 "H","H","S","H", "H", "H", "D", "H", "H",
                 "H","H","H","S","H", "H", "H", "H", "H",
                 "H","H","H","H","S"]

thorpesAce =    ["H", "H", "H", "H", "H", "S", "S", "S",
                   "H", "H", "H", "H", "D", "Ds", "S", "S",
                   "H", "H", "D", "D", "D", "Ds", "S", "S",
                   "D", "D", "D", "D", "D", "Ds", "S", "S",
                   "D", "D", "D", "D", "D", "Ds", "S", "S",
                   "H", "H", "H", "H", "H", "S", "S", "S",
                   "H", "H", "H", "H", "H", "S", "S", "S",
                   "H", "H", "H", "H", "H", "H", "S", "S",
                   "H", "H", "H", "H", "H", "H", "S", "S",
                   "H", "H", "H", "H", "H", "H", "S", "S"]

thorpesPair =["P", "P", "H", "D", "P", "P", "P", "P",
              "S", "P", "P", "P", "H", "D", "P", "P",
              "P", "P", "S", "P","P", "P", "H", "D",
              "P", "P", "P", "P", "S", "P", "P", "P",
              "P", "D", "P", "P", "P", "P", "S", "P",
              "P", "P", "P", "D", "P", "P", "P","P",
              "S", "P", "P", "P", "H", "D", "H","P",
              "P", "S", "S", "P","H", "H", "H", "D",
              "H", "H", "P", "P", "S", "P", "H","H",
              "H", "D", "H", "H", "P", "P", "S","P",
              "H", "H", "H", "H", "H", "H", "P","S",
              "S", "P", "H", "H", "H", "H", "H","H",
              "P", "S", "S", "P"]


#enumerate isn't required, just loop for each item in the list

def rando(weights):
    for current in range(len(weights) - 1, -1, -1):
        for inNode in range(len(weights[current])):
            if len(weights[current][inNode]) <= 1:
                rand = random.uniform(0, 0.05)
                pos = random.choice([True, False])
                if pos == True:
                    weights[current][inNode][0] = weights[current][inNode][0] + (rand * weights[current][inNode][0])
                else:
                    weights[current][inNode][0] = weights[current][inNode][0] - (rand * weights[current][inNode][0])
            else:
                for outNode in range(len(weights[current][inNode])):
                    rand = random.uniform(0, 0.1)
                    pos = random.choice([True, False])
                    if pos ==True:
                        weights[current][inNode][outNode] = weights[current][inNode][outNode] + rand * weights[current][inNode][outNode]
                    else:
                        weights[current][inNode][outNode] = weights[current][inNode][outNode] - rand * weights[current][inNode][outNode]
    return weights



class NeuralNetwork: #Need to sort out where the class parameters should go

    def __init__(self, structure, startWeights): #rename hiddenNodeOutput etc #IS THE SELF. ACTUALLY REQUIRED?

        #network structure
        self.structure = structure #Each number represents the weights in each layer of the NN

        self.weights = []

        self.nodeOutputs = [] #Outputs from each node in each layer

        self.nodeInputs = []

        self.deltas = []

        if startWeights == 0:
            for i in range(len(self.structure)-1):
                self.weights.append(np.random.rand(self.structure[i], self.structure[i+1])) #Create and initialise weights
        else:
            self.weights = startWeights

    def sigmoid(self, z):

        return 1/(1+np.exp(-z))

    def propagate(self, testSet, nnType):

        self.nodeInputs = []

        self.nodeOutputs = []

        inputs = []
        if nnType ==0:
            for i in range(4,21):
                if i == testSet[0]:
                    inputs.append(1)
                else:
                    inputs.append(0)

            for i in range(2,12):
                if i == testSet[1]:
                    inputs.append(1)
                else:
                    inputs.append(0)
        elif nnType==1:
            for i in range(4,21,2):
                if i == testSet[0]:
                    inputs.append(1)
                else:
                    inputs.append(0)

            for i in range(2, 12):
                if i == testSet[1]:
                    inputs.append(1)
                else:
                    inputs.append(0)
        else:
            for i in range(9, 12):
                if i == testSet[0]:
                    inputs.append(1)
                else:
                    inputs.append(0)

            for i in range(2, 12):
                if i == testSet[1]:
                    inputs.append(1)
                else:
                    inputs.append(0)


        for i in range(len(self.structure)):

            if i == 0:

                self.nodeInputs.append(inputs)

                self.nodeOutputs.append(self.nodeInputs[-1])

            elif i < len(self.structure)-1:
                self.nodeInputs.append(np.dot(self.nodeOutputs[-1], self.weights[i-1]))
                self.nodeOutputs.append(self.sigmoid(self.nodeInputs[-1]))
            else:
                self.nodeInputs.append(np.dot(self.nodeOutputs[-1], self.weights[i-1]))

                self.nodeOutputs.append(self.sigmoid(self.nodeInputs[-1]))

        return(self.nodeOutputs[-1])

    def BP(self, expected):

        self.deltas = []

        lastLayer = []

        for current in range(len(self.weights) - 1, -1, -1):

            if current == len(self.weights) - 1:

                for inNode in range(len(self.weights[-1])):

                    if len(self.weights[-1][inNode]) <= 1:

                        lastLayer.append([(self.nodeOutputs[-1][0] - expected[0]) * (self.nodeOutputs[-1][0] * (1 - self.nodeOutputs[-1][0])) * self.nodeOutputs[-2][
                                              inNode]])

                    else:

                        for outNode in range(len(self.weights[-1][inNode])):
                            lastLayer.append([(self.nodeOutputs[-1][outNode] - expected[outNode]) * (

                                self.nodeOutputs[-1][outNode] * (1 - self.nodeOutputs[-1][outNode])) *
                                              self.nodeOutputs[-2][

                                                  inNode]])

                self.deltas.append(lastLayer)

                layerDeltas = []

            else:

                layer = current

                for inNode in range(len(self.weights[layer])):

                    weightedSum = 0

                    nodeDeltas = []

                    for outNode in range(len(self.weights[layer][inNode])):

                        for k in range(len(self.nodeOutputs) - 1, layer + 1, -1):

                            for l in range(len(self.nodeOutputs[k])):
                                weightedSum += self.weights[k - 1][outNode][l] * (

                                    self.nodeOutputs[k][l] - expected[l]) * (

                                                   self.nodeOutputs[k][l] * (1 - self.nodeOutputs[k][l]))

                        nodeDeltas.append(weightedSum * (

                            (self.nodeOutputs[layer + 1][outNode] * (1 - self.nodeOutputs[layer + 1][outNode])) *

                            self.nodeOutputs[layer][inNode]))

                    layerDeltas.append(nodeDeltas)

                self.deltas.append(layerDeltas)

        for layer in range(len(self.weights)):

            for node in range(len(self.weights[layer])):

                for weight in range(len(self.weights[layer][node])):
                    self.weights[layer][node][weight] = self.weights[layer][node][weight] - (
                    self.deltas[-(layer + 1)][node][weight])

class Cards:

    suits = ['Spades', 'Hearts', 'Diamonds', 'Clubs']

    values = range(2, 15)

    shoe = []

    discardPile = []

    def __init__(self, decks):

        self.deckSize = decks


    def newShoe(self):
        self.shoe = []

        for i in range(self.deckSize):

            for Card in itertools.product(self.suits,self.values):

                self.shoe.append(Card) #Cartesian Product to Create Deck

        shuffle(self.shoe)



    def getCardName(self, cards): # takes in a list, do we need self here?
        output = []
        for card in cards:
            if card[1] <= 10:
                output.append((str(card[1]) + ' of ' + str(card[0]), card[1]))
            elif card[1] == 11:

                output.append(('Jack of' + ' ' + card[0], 10))

            elif card[1] == 12:

                output.append(('Queen of' + ' ' + card[0], 10))

            elif card[1] == 13:

                output.append(('King of' + ' ' + card[0], 10))

            elif card[1] == 14:

                output.append(('Ace of' + ' ' + card[0], 11))
        return output

    def deal(self, amount): #returns a list of cards
        dealCards = []
        if len(self.shoe) < 0.25 * (self.deckSize * 52):
            del self.shoe[:]
            self.newShoe()
        for i in range(amount):
            dealCards.append(self.shoe[0])
            del self.shoe[0]
        return dealCards

class Game:

    winCount = 0

    drawCount = 0

    loseCount = 0

    playerList = []

    counter = 0

    money = 20000

    blackjackCount = 0

    def __init__(self, numberOfPlayers,decks, hands, agent):
        self.agent = agent
        self.playerCount = numberOfPlayers
        self.cards = Cards(decks)
        self.handCount = hands
        self.setUp()


    def setUp(self):
        global split
        global double
        if self.agent =="nn"or self.agent =="thorpe":
            split = True
            double = True
        else:
            split = False
            double = False

        self.playerList = []
        player = Player("Dealer")
        self.playerList.append(player)
        for i in range(self.playerCount):
            player = Player("Player "+ str(i))
            self.playerList.append(player)
        self.hand()

    def split(self, player, pair):
        hands = [[pair[0], self.cards.deal(1)[0]], [pair[1], self.cards.deal(1)[0]]]
        for each in hands:
            if each[0][1]==each[1][1] and each[0][1] not in [4,5,10,11,12,13]:
                dCard = self.playerList[0].playerCards[0][4][1]
                if 9 < dCard and dCard < 14:
                    dCard = 10
                elif dCard == 14:
                    dCard = 11
                if each[0][1] == 14:
                    pCard = 11
                else:
                    pCard = each[0][1]
                if self.agent =="nn":
                    decision = splitNN.propagate([pCard, dCard], 1)
                elif self.agent == "thorpe":
                     decision = self.thorpes([[pCard, 1, 0], dCard])
                     if decision == "P":
                        decision  = 1
                     else:
                         decision =0

                if decision >= 0.5:
                    self.split(player, each)
                else:
                    player.playerCards.append(each)
            else:
                player.playerCards.append(each)

    def dealerAction(self):
        dealer = self.playerList[0]
        dealerCards = self.cards.getCardName(dealer.playerCards[0][4:])  # cards object required?
        if printMode:
            print("The dealer reveals his second card, it is the", dealerCards[1][0])  ##
            print("The dealer has a score of", dealer.playerCards[0][1], "\n")  ##

        player = self.playerList[1]
        for hand in player.playerCards:
            if hand[1] < 22:
                while (True):
                    if dealer.playerCards[0][1] < 17: #and dealer.playerCards[0][1] <= hand[1]:
                        dealer.playerCards = [self.twist(dealer, dealer.playerCards[0])]
                    else:
                        break
    def thorpes(self, inputs):
        if inputs[0][1]==1:
            splittable = "Splittable"
        else:
            splittable = "Unsplittable"
        if inputs[0][2]==1:
            ace = "soft"
        else:
            ace = "hard"

        if inputs[0][1]== 1:
            action = thorpesPair[(10 * (inputs[1] - 2)) + int((inputs[0][0]/2) - 2)]

        elif inputs[0][2]>0:
            action = thorpesAce[(8*(inputs[1]-2)) + (inputs[0][0]-13)]

        else:
            if inputs[0][0] > 17:
                inputs[0][0] = 17
            if inputs[0][0]<8:
                inputs[0][0]=8
            action = thorpesSimple[(10*(inputs[1]-2))+(inputs[0][0]-8)]

        #print(inputs[0][0], inputs[1], splittable, ace, action)

        return action

    def hand(self):
        #global gameCount
        for i in range(self.handCount):
            for player in self.playerList:
                player.playerCards = []

                cards = self.cards.deal(2)  # deal cards to players -> [("diamonds", 10), ("diamonds", 9)]
                if player.playerID!="Dealer" and splitTrain:
                    cards = [cards[0], cards[0]]

                dealtCards = self.cards.getCardName(cards)

                player.playerCards.append(cards)
                if player.playerID != "Dealer":
                    #gameCount+=1
                    if printMode:
                        print(player.playerID + "'s cards are the", dealtCards[0][0], "and the", dealtCards[1][0],
                              ": Score =", dealtCards[0][1] + dealtCards[1][1])  ##

                else:
                    if printMode:
                        print("\n\n\nThe " + player.playerID + "'s shown card is the", dealtCards[0][0], ": Score =",
                              self.cards.getCardName(player.playerCards[0])[0][1])  ##

                if split and player.playerID != "Dealer":
                    if cards[0][1] == cards[1][1] and cards[0][1] not in [4, 5, 10, 11, 12, 13]:
                        dCard = self.playerList[0].playerCards[0][4][1]
                        if 9 < dCard and dCard < 14:
                            dCard = 10
                        elif dCard == 14:
                            dCard = 11
                        if cards[0][1] == 14:
                            pCard = 12
                        else:
                            pCard = 2 * cards[0][1]

                        if self.agent =="nn":
                            decision = splitNN.propagate([pCard, dCard], 1)
                        elif self.agent =="thorpe":
                            decision = self.thorpes([[pCard, 1, 0], dCard])
                            if decision == "P":
                                decision = 1
                            else:
                                decision = 0

                        if decision >= 0.5:
                            if printMode:
                                print(decision, "Player has decided to split")
                            self.split(player, cards)
                            del player.playerCards[0]
                        else:
                            if printMode:
                                print(decision, "Player has decided not to split")



                for hand in player.playerCards:
                    aces = 0

                    if hand[0][1] == 14:
                        aces += 1

                    if hand[1][1] == 14:
                        aces += 1

                    hand.insert(0, aces) #insert into position 0 - ace count
                    hand.insert(1, 0) #insert into position 1 - 0(current score count)
                    hand.insert(2,0) #insert into position 2 - 0 (No double down at this point)
                    hand.insert(3, 0)
                    if len(hand[4:]) > 1 or hand[4][1] == hand[5][1]: #Was splitting possible?
                        hand[3] == 1


                    dealtCards = self.cards.getCardName(
                        hand[4:])  # could save this as a separate variable in player class ###########

                    if hand[0] != 2:
                        hand[1] = dealtCards[0][1] + dealtCards[1][1]
                    else:
                        hand[1] = 12
                        hand[0] -= 1

                    if double == True and player.playerID != "Dealer" and 8 < hand[1] < 12:
                        # print("Double hand?", hand)

                        dCard = self.playerList[0].playerCards[0][4][1]
                        if 9 < dCard and dCard < 14:
                            dCard = 10
                        elif dCard == 14:
                            dCard = 11

                        if self.agent =="nn":
                            decision = doubleNN.propagate([hand[4][1] + hand[5][1], dCard], 2)
                        elif self.agent =="thorpe":
                            decision = self.thorpes([[hand[4][1] + hand[5][1], 0, hand[0]], dCard])
                            if decision == "D" or decision == "Ds":
                                decision = 1
                            else:
                                decision = 0


                        if decision >= 0.5:
                            hand[2] = 1
                        else:
                            hand[2] = 3  # to signify that the option was there to double up

            for player in self.playerList[1:]: #Need to make sure the logic for aces is correct here
                for hand in player.playerCards:
                    if self.agent == "nn" or self.agent == "thorpe":
                        while hand[1] < 21 and hand[2]!=2:
                            values = []
                            aceCount = hand[0]
                            for card in hand[4:]:
                                if 9 < card[1] and card[1]<14: #9 < card[1] <14?
                                    values.append(10)
                                elif card[1]==14:
                                    if aceCount >0:
                                        values.append(11)
                                        aceCount -=1
                                    else:
                                        values.append(1)
                                else:
                                    values.append(card[1])

                            dCard = self.playerList[0].playerCards[0][4][1]
                            if 9 < dCard and dCard < 14:
                                dCard = 10
                            elif dCard == 14:
                                dCard = 11

                            total = 0


                            for i in values:
                                total +=i

                            if self.agent =="nn":
                                decision = drawFoldNN.propagate([total, dCard], 0)  # feeds the input through the network
                            elif self.agent =="thorpe":
                                decision = self.thorpes([[total, 0, hand[0]], dCard])
                                if decision == "H" or decision == "D":
                                    decision = 0
                                else:
                                    decision =1

                            if inverse:
                                if decision >= 0.5:
                                    hand = self.twist(player, hand)
                                else:
                                    break
                            else:
                                if decision <= 0.5:
                                    hand = self.twist(player, hand)
                                    if hand[2]==1:
                                        hand[2] = 2
                                else:
                                    if printMode:
                                        print("Player has decided to stand")
                                    break

                    elif self.agent == "dealer" or self.agent =="thorpe":
                        for player in self.playerList[1:]:
                            while hand[1] < 21:
                                if hand[1] > 16:
                                    break
                                else:
                                    hand = self.twist(player, hand)

                    elif self.agent == "hoyle":
                        dealerCard = self.cards.getCardName(self.playerList[0].playerCards[0][4:])  # HOYLES
                        for player in self.playerList[1:]:
                            while hand[1] < 21:
                                if hand[0] > 0:
                                    if hand[1] > 17:
                                        break
                                elif dealerCard[0][1] < 7:
                                    if hand[1] > 12:
                                        break
                                else:
                                    if hand[1] > 16:
                                        break
                                hand = self.twist(player, hand)


                    elif self.agent == "random":
                        for player in self.playerList[1:]:
                            while hand[1] < 21:
                                rand = random.uniform(0, 1)
                                if rand >= 0.5:
                                    hand = self.twist(player, hand)
                                else:
                                    break

                #################################################################################
                self.dealerAction()
                for hand in player.playerCards:
                    both = False
                    best = (self.playerList[0].playerID, self.playerList[0].playerCards[0][1])  # Code under here could be more efficient

                    if (self.playerList[0].playerCards[0][1]>21 and hand[1]<22) or (hand[1] > self.playerList[0].playerCards[0][1] and hand[1] < 22):
                        best = (player.playerID, hand[1])

                    if hand[1] == 21 and self.playerList[0].playerCards[0][1]==21:
                        both = True
                        if len(hand[4:]) == 2:
                            if len(self.playerList[0].playerCards[0][4:])==2:
                                best ="draw"
                                #self.blackjackCount+=1
                            else:
                                best = "blackjack"
                                self.blackjackCount+=1
                        elif len(self.playerList[0].playerCards[0][4:])==2:
                            best = "dealerWin"
                    elif hand[1]==21 and len(hand[4:]) == 2:
                        best = "blackjack"
                        self.blackjackCount += 1

                    if  both==False and best[0] == self.playerList[0].playerID and best[1] == hand[1] or best == "draw":
                        if printMode:
                            print("The game was a draw")
                        self.drawCount += 1
                        if self.agent == "nn":
                            if not double and not split and self.agent =="nn":
                                if hand[1] < 21:
                                    drawFoldNN.BP([0.5])
                                elif hand[1] == 21 and len(hand[4:]) > 2:
                                    drawFoldNN.BP([0])
                            elif doubleTrain and hand[2]>0:
                                doubleNN.BP([0.5])
                            elif splitTrain and hand[3] == 1:
                                splitNN.BP([0.5])
                    else:
                        if printMode:
                            print(best[0], "wins with a score of", best[1])  ##
                        if both==False and best[0] == self.playerList[1].playerID or best =="blackjack":
                            if splitTrain and hand[3]==1:
                                splitNN.BP([1])
                            elif not double and not split and self.agent =="nn":
                                if best[1] < 21:
                                    drawFoldNN.BP([1])
                                elif best[1] == 21 and len(hand[4:]) > 2:
                                    drawFoldNN.BP([0])
                            if double and hand[2] > 0:
                                if doubleTrain:
                                    doubleNN.BP([1])
                                if hand[2]==2:
                                    self.winCount += 2
                                    self.money+=2
                                else:
                                    self.winCount += 1
                                    self.money +=1
                            else:
                                self.winCount +=1
                                self.money+=1
                            if best == "blackjack":
                                self.money+=0.5
                        else:
                            if double and hand[2] > 0:
                                if hand[2] == 2:
                                    self.loseCount += 2
                                    self.money-=2
                                else:
                                    self.loseCount += 1
                                    self.money -=1
                            else:
                                self.loseCount +=1
                                self.money-=1

                            if not double and not split and self.agent =="nn":
                                if hand[1] < 21:
                                    drawFoldNN.BP([0])
                                elif hand[1] > 21:  #############else
                                    drawFoldNN.BP([1])
                            elif splitTrain and hand[3] == 1:
                                splitNN.BP([0])
                            elif doubleTrain and hand[2]>0:
                                doubleNN.BP([0])

    def twist(self, player, hand):
        if printMode:
            print(player.playerID, "has decided to twist... \n")##
        card = self.cards.deal(1)[0]
        if card[1] == 14:
            hand[0]+=1
        hand.append(card)
        dealtCards = self.cards.getCardName(hand[4:])
        total = hand[1] + dealtCards[-1][1]
        if total > 21 and hand[0] > 0:
            total-=10
            hand[0]-=1
        hand[1] = total

        if printMode:
            print("The", dealtCards[-1][0], "was dealt")

        if not split and not double and player.playerID!="Dealer" and self.agent=="nn":
            if total <=21:
                drawFoldNN.BP([0])
        return hand


def GA(hands, population, generations, NN):
    global split
    global splitTrain
    global double
    global doubleTrain
    global previousWin
    global previousWeights
    global overallWin
    global overallWeights

    if NN == drawFoldNN:
        split = False
        splitTrain = False
        double = False
        doubleTrain = False
    elif NN == splitNN:
        split = True
        splitTrain = True
        double = False
        doubleTrain = False
    elif NN == doubleNN:
        double = True
        doubleTrain = True
        split = False
        splitTrain = False

    overallWin = 0
    overallWeights = []

    previousWin = 0
    previousWeights = []
    for i in range(generations): #change back to NN
        currentWin = 0
        currentWeights = []
        for n in range(population):  # population
            if i > 0 and n > 0:
                NN.weights = rando(overallWeights)
            else:
                if NN == drawFoldNN:
                    NN = NeuralNetwork((27, 2, 1), 0)
                elif NN == splitNN:
                    NN = NeuralNetwork((19, 5, 1), 0)
                elif NN == doubleNN:
                    NN = NeuralNetwork((13, 2, 1), 0)

            game = Game(1, 6, hands, "nn")
            if game.winCount/(game.winCount+game.drawCount+game.loseCount) >= currentWin:
                currentWin = game.winCount/(game.winCount+game.drawCount+game.loseCount)
                currentWeights = drawFoldNN.weights
        previousWin = currentWin
        previousWeights = currentWeights
        if previousWin >= overallWin:
            overallWin = previousWin
            overallWeights = previousWeights
    return overallWeights, overallWin


class Player:

    def __init__(self, ID):

        self.playerID = (ID)

        self.playerCards = []

if __name__ == '__main__':
    start_time = time.time()
    hands = 200000
    population = 10
    generations = 10

    drawFoldNN = NeuralNetwork((27, 2, 1), 0)
    splitNN = NeuralNetwork((19, 5, 1), 0)
    doubleNN = NeuralNetwork((13, 2, 1), 0)


    for nn in [drawFoldNN]: #,doubleNN, splitNN
        print("run")
        weights, winRate = GA(hands, population, generations, nn)
        bestResultsArray.append(winRate)
        bestWeightsArray.append(weights)


    #print("best weights array", bestWeightsArray)
    #print("best results array", bestResultsArray)
    #print("drawFoldNN", drawFoldNN)


    #split = True
    #double = True
    #splitTrain = False
    #doubleTrain = False



    game = Game(1, 6, hands, "thorpe")
    print("Dealer Win rate", ((game.winCount + (0.5* game.blackjackCount)) * 100 / (game.winCount + game.drawCount + game.loseCount)))
    print("Dealer Lose rate", (game.loseCount * 100 / (game.winCount + game.drawCount + game.loseCount)))
    print("Dealer Draw rate", (game.drawCount * 100 / (game.winCount + game.drawCount + game.loseCount)))
    print("Money", game.money, "money/games", game.money/(game.winCount + game.drawCount + game.loseCount))

    #print("blackjackCount:", game.blackjackCount, game.blackjackCount/hands)

    #drawFoldNN.weights = bestWeightsArray[0]
    #game = Game(1, 6, 200000, "hoyle")
    #print("hoyle", (game.winCount * 100 / (game.winCount + game.drawCount + game.loseCount)))



    #print("split", splitNN.weights)
    #print("double", doubleNN.weights)
    '''counter = 0
    for i in bestWeightsArray:
        if counter==0:
            print("drawFoldNN Weights", i)
        elif counter ==1:
            print("splitNN Weights", i)
        else:
            print("doubleNN Weights", i)
        counter +=1'''

    #print("--- %s seconds ---" % (time.time() - start_time))
